# 1.题目

现有`n`件任务和无限多台的机器，任务可以在机器上得到处理。每件任务的开始时间为`si`，完成时间为`fi`，`s1 < fi`。`[si, fi]`为处理任务`i`的时间范围。两个任务`i`，`j`重叠是指两个任务的时间范围区间有重叠，而并非是指`i`，`j`的起点或终点重合。例如：区间`[1, 4]`与区间`[2, 4]`重叠，而与区间`[4, 7]`不重叠。一个可行的任务分配是指在分配中没有两件重叠的任务分配给同一台机器。因此，在可行的分配中每台机器在任何时刻最多只处理一个任务。最优分配是指使用的机器最少的可行分配方案。

# 2.题解

这个问题是**区间调度问题的变体**，也称为**最小机器调度问题**（Interval Partitioning Problem），核心目标是**最小化分配机器的数量**，确保没有两个重叠任务分配到同一台机器。

## 2.1 问题分析

- 给定 `n` 个任务，每个任务有一个**开始时间** `s[i]` 和一个**完成时间** `f[i]`，其中 `[s[i], f[i])` 表示任务的处理时间区间。
- 如果两个任务的时间区间重叠，它们**不能分配到同一台机器**。
- 目标是**使用最少的机器**来完成所有任务的调度。

## 2.2 解决思路

**贪心策略 + 时间线扫描法:**

解决这个问题的关键是观察任务的**开始时间和结束时间**之间的关系，利用时间线扫描法（**扫描线算法**）解决：

1. **事件建模**：将任务的时间分为两类事件：
    - **开始事件**：`s[i]`，表示任务开始。
    - **结束事件**：`f[i]`，表示任务结束。

2. **排序事件**：
    - 将所有事件按照**时间**排序。
    - 如果时间相等，先处理**开始事件**，再处理**结束事件**。

3. **扫描时间线**：
    - 用一个变量 `count` 记录当前同时运行的任务数量。
    - 每遇到一个**开始事件**，`count + 1`。
    - 每遇到一个**结束事件**，`count - 1`。
    - 在扫描过程中，`count` 的最大值就是所需的最少机器数量。

## 2.3 输入输出示例

输入示例
```
Enter the number of tasks: 5
Enter the start and end time of each task:
1 4
2 5
3 6
7 8
5 9
```

输出示例
```
The minimum number of machines required: 3
```

## 2.4 代码解释

1. **事件建模**：
    - 每个任务的开始时间和结束时间被视为两个事件，分别用 `1` 和 `-1` 标记。
    - 例如任务 `[1, 4]` 会被拆分为两个事件：`{1, 1}` 和 `{4, -1}`。

2. **排序规则**：
    - 事件按照时间升序排序。
    - 在时间相同时，**开始事件优先**，因为要先占用资源（机器），后释放资源。

3. **扫描线逻辑**：
    - 遍历事件，遇到开始事件 `count + 1`，遇到结束事件 `count - 1`。
    - 在扫描过程中，`count` 的最大值就是同时需要的最大机器数量。