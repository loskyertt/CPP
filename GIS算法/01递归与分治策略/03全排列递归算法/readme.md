可以用一个具体的例子详细解释递归函数中`swap`的作用。考虑 `nums = {1, 2, 3}` 的情况。

前后两个 swap 的目的是：
1. 第一个 swap：用来将当前要尝试的数字交换到`start`位置，生成新的排列可能
2. 第二个 swap：用来恢复原数组状态，以便进行下一次尝试（这就是所谓的回溯）

再看看具体执行过程：
```cpp
void generatePermutations(vector<int>& nums, int start, vector<vector<int>>& result)
{
    if (start == nums.size() - 1) {
        result.push_back(nums);
        return;
    }

    for (int i = start; i < nums.size(); i++) {
        // 第一个swap：将i位置的数字交换到start位置
        swap(nums[start], nums[i]);

        // 递归生成后续排列
        generatePermutations(nums, start + 1, result);

        // 第二个swap：恢复原状（回溯）
        swap(nums[start], nums[i]);
    }
}
```

让我们一步步看执行过程（以第一层递归为例）：

1. **第一次循环 (i = 0)**：
   ```
   初始：nums = {1,2,3}
   第一个swap(0,0)：{1,2,3}  // 自己和自己交换，没变化
   递归调用
   第二个swap(0,0)：{1,2,3}  // 恢复原状，没变化
   ```

2. **第二次循环 (i = 1)**：
   ```
   初始：nums = {1,2,3}
   第一个swap(0,1)：{2,1,3}  // 1和2交换
   递归调用
   第二个swap(0,1)：{1,2,3}  // 恢复原状，重要！
   ```

3. **第三次循环 (i = 2)**：
   ```
   初始：nums = {1,2,3}
   第一个swap(0,2)：{3,2,1}  // 1和3交换
   递归调用
   第二个swap(0,2)：{1,2,3}  // 恢复原状，重要！
   ```

**为什么需要第二个 swap（回溯）？**

假设没有第二个`swap`，让我们看看会发生什么：
```cpp
// 如果没有第二个swap
第一次循环 (i=0): {1,2,3} -> 递归
第二次循环 (i=1): {2,1,3} -> 递归  // 基于{2,1,3}继续
第三次循环 (i=2): {3,1,2} -> 递归  // 基于{3,1,2}继续
```

这样会导致每次循环都是基于上一次改变后的数组继续，而不是基于原始数组，这会导致：
1. 无法生成所有可能的排列
2. 可能会重复生成某些排列
3. 最终结果不正确

**关键点总结：**
1. 第一个`swap`是为了生成新的排列可能
2. 第二个`swap`是为了回溯，恢复数组到之前的状态
3. 这种"尝试-回溯"的模式是回溯算法的典型特征
4. 回溯确保了每次循环都是基于相同的起始状态进行的

可以把这个过程想象成：
1. 第一个`swap`是"尝试一种可能"
2. 递归是"基于这种可能继续探索"
3. 第二个`swap`是"撤销这次尝试，准备尝试下一种可能"

这就像在走迷宫时：
1. 第一个`swap`相当于"走进一条路"
2. 递归相当于"在这条路上继续探索"
3. 第二个`swap`相当于"回到岔路口，准备尝试另一条路"