**问题：**
将正整数`n`表示成一系列正整数之和：`n=n1 + n2 + … + nk`，其中`n1 ≥ n2 ≥ … ≥ nk ≥ 1`，`k≥1`。正整数`n`的这种表示称为正整数`n`的划分，求正整数`n`的不同划分个数。
例如，正整数 6 有如下 11 种不同的划分：
```txt
6；
5+1；
4+2，4+1+1；
3+3，3+2+1，3+1+1+1；
2+2+2，2+2+1+1，2+1+1+1+1；
1+1+1+1+1+1。
```

**思路：**
如果要用递归的方式来求解，那就需要先找到边界条件。如果设`partition(n)`为正整数`n`的划分数，则难以找到递归关系，因此考虑增加一个自变量：将最大加数`n1`不大于`m`的划分个数记作`partition(n, m)`，表示待拆分的整数`n`，拆分出来的部分最大值不超过`m`。
这样就可以建立`partition(n, m)`的如下递归关系：
```c++
partition(n, 1) = 1;    // 表示拆分的最大数是 1，只有一种情况，比如：6=1+1+1+1+1+1
partition(1, m) = 1;    // 表示 1 作擦拆分，也只有一种情况：1=1
``

现在考虑非边界条件：
```c++
n < m : partition(n, m) = partition(n, n);
n = m : partition(n, m) = partition(n, m - 1) + 1;  // 这种情况看成：包含 m + 不包含 m
n > m : partition(n, m) = partition(n - m, m) + partition(n, m - 1); // 表示：拆分方案中至少包含了一个 m 和 拆分方案中不包含 m
```

当然，这个条件也能转换成状态转移方程，然后用动态规划来求解。